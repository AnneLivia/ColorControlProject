#include <iostream>
#include <opencv2/opencv.hpp>
#include <windows.h>

using namespace std;
using namespace cv;

void cancel_keys_except(const string& key);
void press_key(const string& key);

int main()
{
    VideoCapture cap(0);

    cap.set(CAP_PROP_FRAME_WIDTH, 700);
    cap.set(CAP_PROP_FRAME_HEIGHT, 600);

    Mat frame;

    int cont = 0; // get all four fingers

    while(true) {
        cap.read(frame);
        // drawing place where to insert the hand
        rectangle(frame, Point(20, 140), Point(250, 370), Scalar(255,255,255), 4);

        Mat roiImage = frame(Rect(Point(20, 140), Point(250, 370)));

        switch(cont) {
            case 0:
                putText(frame, "Finger UP", Point(18, 80), FONT_HERSHEY_PLAIN, 4.0, Scalar(255, 255, 255), 2);
                if (waitKey(33) == 'a') {
                    imwrite("template_fingers/fingerUP.jpg", roiImage);
                    cont++;
                }
                break;
            case 1:
                putText(frame, "Finger Down", Point(18, 80), FONT_HERSHEY_PLAIN, 4.0, Scalar(255, 255, 255), 2);
                if (waitKey(33) == 'a') {
                    imwrite("template_fingers/fingerDown.jpg", roiImage);
                    cont++;
                }
                break;
            case 2:
                putText(frame, "Finger Left", Point(18, 80), FONT_HERSHEY_PLAIN, 4.0, Scalar(255, 0, 0), 2);
                if (waitKey(33) == 'a') {
                    imwrite("template_fingers/fingerLeft.jpg", roiImage);
                    cont++;
                }
                break;
            case 3:
                putText(frame, "Finger Right", Point(18, 80), FONT_HERSHEY_PLAIN, 4.0, Scalar(255, 0, 0), 2);
                if (waitKey(33) == 'a') {
                    imwrite("template_fingers/fingerRight.jpg", roiImage);
                    cont++;
                }
                break;
        }

        Mat grayFrame;



        Mat template_fingerUP = imread("template_fingers/fingerUP.jpg", IMREAD_GRAYSCALE);
        Mat template_fingerDown = imread("template_fingers/fingerDown.jpg", IMREAD_GRAYSCALE);
        Mat template_fingerLeft = imread("template_fingers/fingerLeft.jpg", IMREAD_GRAYSCALE);
        Mat template_fingerRight = imread("template_fingers/fingerRight.jpg", IMREAD_GRAYSCALE);


        cvtColor(frame, grayFrame, COLOR_BGR2GRAY);

        Mat result1, result2, result3, result4;
        matchTemplate(grayFrame, template_fingerUP, result1, TM_CCORR_NORMED);
        matchTemplate(grayFrame, template_fingerDown, result2, TM_CCORR_NORMED);
        matchTemplate(grayFrame, template_fingerLeft, result3, TM_CCORR_NORMED);
        matchTemplate(grayFrame, template_fingerRight, result4, TM_CCORR_NORMED);

        // Find points where there are the highest match
        vector<Point> highestMatchPen1;
        for(int i = 0; i < result1.rows; i++) {
            for(int j = 0; j < result1.cols; j++) {
                if(result1.at<float>(i,j) >= 0.7) {
                    highestMatchPen1.push_back(Point(j,i));
                }
            }
        }


        // Find points where there are the highest match
        vector<Point> highestMatchPen2;
        for(int i = 0; i < result2.rows; i++) {
            for(int j = 0; j < result2.cols; j++) {
                if(result2.at<float>(i,j) >= 0.7) {
                    highestMatchPen2.push_back(Point(j,i));
                }
            }
        }

        // Find points where there are the highest match
        vector<Point> highestMatchPen3;
        for(int i = 0; i < result3.rows; i++) {
            for(int j = 0; j < result3.cols; j++) {
                if(result3.at<float>(i,j) >= 0.7) {
                    highestMatchPen3.push_back(Point(j,i));
                }
            }
        }


        // Find points where there are the highest match
        vector<Point> highestMatchPen4;
        for(int i = 0; i < result4.rows; i++) {
            for(int j = 0; j < result4.cols; j++) {
                if(result4.at<float>(i,j) >= 0.7) {
                    highestMatchPen4.push_back(Point(j,i));
                }
            }
        }

        if (cont >= 4) {
            if (highestMatchPen1.size() > highestMatchPen2.size() &&
                highestMatchPen1.size() > highestMatchPen3.size() &&
                highestMatchPen1.size() > highestMatchPen4.size()) {

                 cancel_keys_except("up");
                 press_key("up");

                for(Point i : highestMatchPen1) {
                    rectangle(frame, Point(i.x, i.y), Point(i.x + 40, i.y + 40), Scalar(255,255,0), 2);
                }
            } else if (highestMatchPen2.size() > highestMatchPen1.size() &&
                highestMatchPen2.size() > highestMatchPen3.size() &&
                highestMatchPen2.size() > highestMatchPen4.size()) {

                cancel_keys_except("down");
                press_key("down");

                for(Point i : highestMatchPen2) {
                    rectangle(frame, Point(i.x, i.y), Point(i.x + 40, i.y + 40), Scalar(255,0,0), 2);
                }


            }  else if (highestMatchPen3.size() > highestMatchPen1.size() &&
                highestMatchPen3.size() > highestMatchPen2.size() &&
                highestMatchPen3.size() > highestMatchPen4.size()) {
                cancel_keys_except("left");
                press_key("left");


                 for(Point i : highestMatchPen3) {
                    rectangle(frame, Point(i.x, i.y), Point(i.x + 40, i.y + 40), Scalar(255,0,255), 2);
                }
            } else {
                cancel_keys_except("right");
                press_key("right");


                for(Point i : highestMatchPen4) {
                    rectangle(frame, Point(i.x, i.y), Point(i.x + 40, i.y + 40), Scalar(0,255,255), 2);
                }
            }
        }

        imshow("Frame", frame);
        imshow("FrameROI", roiImage);
        waitKey(1);
    }
    return 0;
}


// method used to pass the arrow key to be pressed
void press_key(const string& key) {
    if (key == "up") {
        keybd_event(VK_UP, 0, 0, 0);
    } else if (key == "left") {
        keybd_event(VK_LEFT, 0, 0, 0);
    } else if (key == "right") {
        keybd_event(VK_RIGHT, 0, 0, 0);
    } else if (key == "down") {
        keybd_event(VK_DOWN, 0, 0, 0);
    }
}

// method used to unpressed other keys, if the user wants to press some keys, others must be unpressed
void cancel_keys_except(const string& key) {
    if (key == "up") {
        keybd_event(VK_DOWN, 0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_LEFT,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_RIGHT,0,KEYEVENTF_KEYUP,0);
    } else if (key == "left") {
        keybd_event(VK_DOWN, 0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_UP,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_RIGHT,0,KEYEVENTF_KEYUP,0);
    } else if (key == "right") {
        keybd_event(VK_DOWN, 0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_UP,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_LEFT,0,KEYEVENTF_KEYUP,0);
    } else if (key == "down") {
        keybd_event(VK_UP,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_LEFT,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_RIGHT,0,KEYEVENTF_KEYUP,0);
    } else if (key == "") {
        keybd_event(VK_DOWN, 0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_UP,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_LEFT,0,KEYEVENTF_KEYUP,0);
        keybd_event(VK_RIGHT,0,KEYEVENTF_KEYUP,0);
    }
}

